<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultra Smooth Wheel Carousel</title>

  <style>
    :root{
      --L: 160px;

      --dur: 780ms;
      --ease: cubic-bezier(.12, 1.05, .18, 1);

      --glow-1: rgba(255, 200, 90, .58);
      --glow-2: rgba(255, 150, 40, .38);
    }

    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#111;
      color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }

    .wheel{
      width:286px;
      height:786px;
      position:relative;
      overflow:hidden;
      border-radius:28px;
      background: rgba(255,255,255,.035); /* мягкий общий фон, без полосы по центру */
      user-select:none;
      touch-action:pan-y;
    }

    .item{
      position:absolute;
      left:50%;
      top:50%;
      width:var(--L);
      height:var(--L);
      transform: translate3d(-50%, -50%, 0) translate3d(0, var(--y), 0) scale(var(--s));
      opacity: var(--o);

      transition:
        transform var(--dur) var(--ease),
        opacity  var(--dur) var(--ease),
        filter   var(--dur) var(--ease),
        box-shadow var(--dur) var(--ease);
      will-change: transform, opacity;

      display:grid;
      place-items:center;
      border-radius:22px;

      background:#1a1a1a;
      box-shadow:
        0 0 0 2px rgba(255,185,70,0.28),
        0 0 28px rgba(255,185,70,0.18);
    }

    .item.noTrans{ transition:none !important; }

    .label{
      font-weight:700;
      letter-spacing:.06em;
      font-size:12px;
      text-transform:uppercase;
      opacity:.95;
    }

    /* Активная (самая большая) — подсветка только у неё */
    .item[data-level="L"]{
      filter: saturate(1.14) brightness(1.10) blur(0px);
      box-shadow:
        0 0 0 3px rgba(255,185,70,0.55),
        0 0 46px var(--glow-1),
        0 0 110px var(--glow-2);
    }

    .item[data-level="M"]{
      filter: saturate(1.02) brightness(1.02) blur(.15px);
    }

    .item[data-level="S"]{
      filter: saturate(.95) brightness(.98) blur(.35px);
    }

    @media (prefers-reduced-motion: reduce){
      .item{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="wheel" id="wheel" aria-label="Вертикальная карусель">
    <!-- 9 элементов: позиции -4..+4 -->
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
    <div class="item"><div class="label"></div></div>
  </div>

  <script>
    const DATA = ["Keno","Slot","Favorites","Fishing","Others","Poker","Roulette","Blackjack","Baccarat","Crash","Aviator"];

    const wheel = document.getElementById('wheel');
    const items = Array.from(wheel.querySelectorAll('.item'));

    // Design tokens (from Figma): L=160, M=120, S=90, GAP=29px
    const L = 160, M = 120, S = 90, GAP = 29;

    const d1 = (L + M)/2 + GAP;              // 169
    const d2 = d1 + (M + S)/2 + GAP;         // 303
    const stepSS = (S + S)/2 + GAP;          // 119

    let d3 = 0, d4 = 0, SLOT = null;

    const mod = (n, m) => ((n % m) + m) % m;

    let activeIndex = 2;
    let animLock = false;

    // очередь шагов для мягкого wheel
    const queue = [];
    function enqueueStep(dir){
      queue.push(dir);
      pumpQueue();
    }

    async function pumpQueue(){
      if (animLock) return;
      if (queue.length === 0) return;
      animLock = true;

      while (queue.length){
        const dir = queue.shift();
        await doStep(dir);
      }

      animLock = false;
    }

    function computeOffscreen(){
      const rect = wheel.getBoundingClientRect();
      const halfH = rect.height / 2;

      const minOffscreen = halfH + (L / 2) + 260;

      d3 = Math.max(d2 + stepSS, minOffscreen);
      d4 = d3 + stepSS + 320;
    }

    function buildSlots(){
      SLOT = {
        "-4": { y:-d4, s:(S/L), o:0.0,  level:"S" },
        "-3": { y:-d3, s:(S/L), o:0.0,  level:"S" },
        "-2": { y:-d2, s:(S/L), o:0.70, level:"S" },
        "-1": { y:-d1, s:(M/L), o:0.88, level:"M" },
         "0": { y:  0, s:1.0,   o:1.0,  level:"L" },
         "1": { y: d1, s:(M/L), o:0.88, level:"M" },
         "2": { y: d2, s:(S/L), o:0.70, level:"S" },
         "3": { y: d3, s:(S/L), o:0.0,  level:"S" },
         "4": { y: d4, s:(S/L), o:0.0,  level:"S" }
      };
    }

    function setContent(el, dataIdx){
      el.querySelector('.label').textContent = DATA[mod(dataIdx, DATA.length)];
      el.dataset.dataIndex = String(mod(dataIdx, DATA.length));
    }

    function setVisual(el, pos, instant=false){
      const p = SLOT[String(pos)];
      if (!p) return;

      if (instant) el.classList.add('noTrans');

      el.style.setProperty('--y', `${p.y}px`);
      el.style.setProperty('--s', `${p.s}`);
      el.style.setProperty('--o', `${p.o}`);
      el.dataset.pos = String(pos);
      el.dataset.level = p.level;

      if (instant){
        requestAnimationFrame(() => el.classList.remove('noTrans'));
      }
    }

    function init(){
      items.forEach((el, i) => {
        const pos = i - 4;
        setVisual(el, pos, true);
        setContent(el, activeIndex + pos);
      });
    }

    function doStep(dir){
      return new Promise((resolve) => {
        const newActive = mod(activeIndex + dir, DATA.length);
        const delta = (dir === 1) ? -1 : 1;

        const wrapFrom = (delta === -1) ? -4 : 4;
        const wrapTo   = (delta === -1) ?  4 : -4;

        const wrapEl = items.find(el => parseInt(el.dataset.pos, 10) === wrapFrom);

        if (wrapEl){
          setContent(wrapEl, newActive + wrapTo);
          setVisual(wrapEl, wrapTo, true);
        }

        items.forEach(el => {
          let pos = parseInt(el.dataset.pos, 10);
          let nextPos = pos + delta;

          if (nextPos < -4) nextPos = 4;
          if (nextPos >  4) nextPos = -4;

          setVisual(el, nextPos, false);
        });

        const done = () => {
          wheel.removeEventListener('transitionend', done);
          activeIndex = newActive;
          resolve();
        };

        wheel.addEventListener('transitionend', done, { once:true });
      });
    }

    // wheel только при наведении
    let hovered = false;
    wheel.addEventListener('mouseenter', () => hovered = true);
    wheel.addEventListener('mouseleave', () => hovered = false);

    let wheelAccum = 0;
    let wheelTimer = null;

    wheel.addEventListener('wheel', (e) => {
      if (!hovered) return;
      e.preventDefault();

      wheelAccum += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        const dir = Math.sign(wheelAccum);
        const amount = Math.min(3, Math.max(1, Math.floor(Math.abs(wheelAccum) / 120)));
        for (let i = 0; i < amount; i++){
          enqueueStep(dir > 0 ? 1 : -1);
        }
        wheelAccum = 0;
      }, 60);
    }, { passive:false });

    // touch swipe
    let startY = 0;
    let dragging = false;

    wheel.addEventListener('touchstart', (e) => {
      if (!e.touches || !e.touches[0]) return;
      dragging = true;
      startY = e.touches[0].clientY;
    }, { passive:true });

    wheel.addEventListener('touchmove', (e) => {
      if (!dragging || !e.touches || !e.touches[0]) return;
      const dy = e.touches[0].clientY - startY;
      const threshold = 28;

      if (Math.abs(dy) >= threshold){
        enqueueStep(dy < 0 ? 1 : -1);
        startY = e.touches[0].clientY;
      }
    }, { passive:true });

    wheel.addEventListener('touchend', () => dragging = false, { passive:true });

    requestAnimationFrame(() => {
      computeOffscreen();
      buildSlots();
      init();
    });

    window.addEventListener('resize', () => {
      computeOffscreen();
      buildSlots();
      items.forEach(el => {
        const pos = parseInt(el.dataset.pos, 10);
        setVisual(el, pos, true);
      });
    });
  </script>
</body>
</html>
